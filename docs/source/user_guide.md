# User Guide

The idea of the `pyEvalData` module is to provide a simple but yet flexible way
for reading and evaluating scientific data acquired at synchrotrons, FELs, or
in the lab.  
It is written with the intend to reuse available code as much as possible and
to simplify the access to complex data formats and very general evaluation and 
analysis procedures.  
Generally, students and scientists should focus on data interpretation rather
than on scripting the same routines again and again.

Please read the upcoming section to understand the concept of reading and
evaluating data with `pyEvalData` and how to extend/configure the module to
your needs.

It is also strongly recommended to follow the [examples](examples).

## General Concepts

The following figure illustrates the main components of the `pyEvalData` module
and their interactions.

![Concept](./_static/concept.png)

### Raw Data

The starting point of most evaluations is any set of raw data files as
generated by an experimental setup consisting of actuators such as motors and
counters such as detectors, cameras, or sensors.

Typical data formats are human readable text files or compressed
[hdf5](https://www.hdfgroup.org/solutions/hdf5/) or
[NeXus](https://www.nexusformat.org/) files. Cameras often use `tiff` or
proprietary file formats.

### Source

The `Source` class provides a common set of methods and attributes to read and
store raw data. It further acts as an `interface` to implement the
source-specific classes.

A `Source` class should be able to parse the raw data to detect all available
scans e.g. in a data file or folder structure and to extract the scan's meta
information such as a *scan number* or *scan command*.
The actual data for a scan must be read by an independent method.

The scan meta information and possibly also the scan data are stored in a
`Scan` object, which provides a general but flexible interface between the
`Source` and `Evaluation` classes. All `Scan` objects of a raw data source are
stored in the `scan_dict` of the `Source` object.

The `pyEvalData` modules provides several build-in `Source` classes, e.g. for 
[spec](https://certif.com/content/spec/),
[hdf5](https://www.hdfgroup.org/solutions/hdf5/), and
[NeXus](https://www.nexusformat.org/) files. It can be easily extended by the
user as explained in the [write your own `Source` section](#write-your-own-source).
It is highly appreciated if such `Source` plugins are shared with the community.

In a future release, it will be possible to join two or multiple `Source`
classes to create a `CompositeSource` object. This will be helpful to read
separate raw data sources originating from the same experiment. A typical
example is a scan file, such as a [spec](https://certif.com/content/spec/) file
and a  folder structure containing camera images, which are linked to the data
points in the scan file. 

### pyEvalData NeXus file

A rather general feature of the `pyEvalData` module is the usage of a
[NeXus](https://www.nexusformat.org/) file for converting the raw data in a
common, structured, fast, and compressed data format. If enabled, the use can
benefit from:
- a single data file containing all raw data - easy portability
- high degree of compression - saves disk space
- fast data access - saves computational time
- common and well documented structure - easy access also by external tools 

### Evaluation

The `Evaluation` class requires any kind of `Source` on initialization.

## Write your own `Source`

## Write your own `Filter`